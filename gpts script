local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local Workspace = game:GetService("Workspace")
local Lighting = game:GetService("Lighting")
local LocalPlayer = Players.LocalPlayer
local Camera = Workspace.CurrentCamera

-- Настройки
local Settings = {
    Keybind = Enum.UserInputType.MouseButton3,
    BoostKeybind = Enum.KeyCode.V,
    TpBackKeybind = Enum.KeyCode.X,
    TargetPart = "HumanoidRootPart",
    LockAngleAtTarget = true,
    -- Настройки предсказания
    UsePrediction = true,
    Prediction = 0.17362,
    JumpOffset = 1.5,
    -- Телепорт
    TeleportDistance = 5,
    -- Визуализация
    PredictionColor = Color3.fromRGB(0, 255, 0),
    PredictionSize = UDim2.new(0, 20, 0, 20),
    PredictionTransparency = 0.5,
    -- Фильтры
    MaxDistance = 1000,
    FOV = 60,
    TargetNPCs = false,
    TargetPlayers = true,
    -- Camlock
    CamlockKeybind = Enum.KeyCode.K,
    CamlockSmoothness = 0.1,
    CamlockEnabled = false
}

-- Состояние
local State = {
    SelectedTarget = nil,
    PredictionGui = nil,
    OriginalAutoRotate = true,
    Connections = {},
    IsBoosting = false,
    LastBoostTime = 0,
    FixedBoostPosition = nil,
    CamlockTarget = nil,
    currentPart = nil
}

-- Создаем визуальные элементы (BillboardGui вместо Part)
local function CreateVisuals()
    State.PredictionGui = Instance.new("BillboardGui")
    State.PredictionGui.Name = "PredictionVisual"
    State.PredictionGui.Size = Settings.PredictionSize
    State.PredictionGui.AlwaysOnTop = true
    State.PredictionGui.Enabled = false
   
    local frame = Instance.new("Frame")
    frame.Size = UDim2.new(1, 0, 1, 0)
    frame.BackgroundColor3 = Settings.PredictionColor
    frame.BackgroundTransparency = Settings.PredictionTransparency
    frame.BorderSizePixel = 0
    frame.Parent = State.PredictionGui
   
    local corner = Instance.new("UICorner")
    corner.CornerRadius = UDim.new(1, 0)
    corner.Parent = frame
   
    State.PredictionGui.Parent = Workspace
end

-- Очищаем визуальные элементы
local function ClearVisuals()
    if State.PredictionGui then
        State.PredictionGui:Destroy()
        State.PredictionGui = nil
    end
    if State.currentPart then
        State.currentPart:Destroy()
        State.currentPart = nil
    end
end

-- Управление autorotate
local function ManageAutoRotate(enable)
    local character = LocalPlayer.Character
    if not character then return end
    local humanoid = character:FindFirstChildOfClass("Humanoid")
    if not humanoid then return end
    if enable then
        humanoid.AutoRotate = State.OriginalAutoRotate
    else
        State.OriginalAutoRotate = humanoid.AutoRotate
        humanoid.AutoRotate = false
    end
end

-- Рассчитываем velocity цели
local function CalculateVelocity(target)
    if not target or not target:FindFirstChild(Settings.TargetPart) then return Vector3.new() end
    return target[Settings.TargetPart].Velocity
end

-- Находим ближайшую цель (игроков или NPC) к курсору
local function FindClosestTargetToCursor()
    local closestTarget = nil
    local closestDistance = math.huge
    local mousePos = UserInputService:GetMouseLocation()
    local mouseRay = Camera:ViewportPointToRay(mousePos.X, mousePos.Y)

    -- Проверка игроков
    if Settings.TargetPlayers then
        for _, player in pairs(Players:GetPlayers()) do
            if player == LocalPlayer or not player.Character or not player.Character:FindFirstChild("Head") then continue end
            local head = player.Character:FindFirstChild("Head")
            local screenPos, onScreen = Camera:WorldToViewportPoint(head.Position)
            if onScreen then
                local screenDistance = (Vector2.new(screenPos.X, screenPos.Y) - mousePos).Magnitude
                if screenDistance < closestDistance then
                    closestDistance = screenDistance
                    closestTarget = player.Character
                end
            end
        end
    end

    -- Проверка NPC
    if Settings.TargetNPCs then
        for _, obj in pairs(Workspace:GetChildren()) do
            if obj ~= LocalPlayer.Character and obj:FindFirstChild(Settings.TargetPart) and not Players:GetPlayerFromCharacter(obj) then
                local targetPart = obj:FindFirstChild(Settings.TargetPart)
                local screenPos, onScreen = Camera:WorldToViewportPoint(targetPart.Position)
                if onScreen then
                    local screenDistance = (Vector2.new(screenPos.X, screenPos.Y) - mousePos).Magnitude
                    if screenDistance < closestDistance then
                        closestDistance = screenDistance
                        closestTarget = obj
                    end
                end
            end
        end
    end

    return closestTarget
end

-- Рассчитываем предсказанную позицию
local function CalculatePrediction(target)
    if not target or not target:FindFirstChild(Settings.TargetPart) then return nil end
    local targetPart = target[Settings.TargetPart]
    local targetPos = targetPart.Position
    local targetVel = CalculateVelocity(target)
    local predictedPos = targetPos
    if Settings.UsePrediction then
        predictedPos = targetPos + (targetVel * Settings.Prediction)
        if targetVel.Y > 15 then
            predictedPos = predictedPos + Vector3.new(0, Settings.JumpOffset, 0)
        end
    end
    return predictedPos
end

-- Создаем визуальный квадратик над целью
local function createPartAbovePlayer(target)
    if target and target:FindFirstChild(Settings.TargetPart) then
        if State.currentPart then
            State.currentPart:Destroy()
        end
        State.currentPart = Instance.new("Part")
        State.currentPart.Size = Vector3.new(1, 1, 1)
        State.currentPart.Material = Enum.Material.Neon
        State.currentPart.BrickColor = BrickColor.new("Bright green")
        State.currentPart.Anchored = true
        State.currentPart.CanCollide = false
        State.currentPart.Position = target[Settings.TargetPart].Position + Vector3.new(0, 3, 0)
        State.currentPart.Parent = Workspace
        game:GetService("Debris"):AddItem(State.currentPart, 5)
    end
end

-- Функция телепорта к цели с учетом предсказания
local function TeleportToTarget()
    if not State.SelectedTarget or not State.SelectedTarget:FindFirstChild(Settings.TargetPart) then return end
    local character = LocalPlayer.Character
    if not character then return end
    local rootPart = character:FindFirstChild("HumanoidRootPart")
    if not rootPart then return end
    local predictedPos = CalculatePrediction(State.SelectedTarget)
    if not predictedPos then return end
    local targetPosition = predictedPos - (State.SelectedTarget.HumanoidRootPart.CFrame.LookVector * Settings.TeleportDistance)
    rootPart.CFrame = CFrame.new(targetPosition, predictedPos)
    local camera = Workspace.CurrentCamera
    camera.CFrame = CFrame.new(targetPosition + Vector3.new(0, 2, 0), predictedPos)
    createPartAbovePlayer(State.SelectedTarget)
end

-- Функция телепорта назад
local function TpBack()
    local character = LocalPlayer.Character
    if not character or not character:FindFirstChild("HumanoidRootPart") then return end
    local rootPart = character.HumanoidRootPart
    local backwardVector = -rootPart.CFrame.LookVector
    local teleportDistance = 9
    local currentLookVector = rootPart.CFrame.LookVector
    local newPosition = rootPart.Position + (backwardVector * teleportDistance)
    rootPart.CFrame = CFrame.new(newPosition, newPosition + currentLookVector)
end

-- Функция поворота персонажа к цели
local function LookAtTarget()
    if not Settings.LockAngleAtTarget or not State.SelectedTarget then
        ManageAutoRotate(true)
        return
    end
    local character = LocalPlayer.Character
    if not character then return end
    local rootPart = character:FindFirstChild("HumanoidRootPart")
    if not rootPart then return end
    local predictedPos = CalculatePrediction(State.SelectedTarget)
    if not predictedPos then return end
    ManageAutoRotate(false)
    local localPos = rootPart.Position
    local aimDirection = (predictedPos - localPos).Unit
    aimDirection = Vector3.new(aimDirection.X, 0, aimDirection.Z).Unit
    rootPart.CFrame = CFrame.new(localPos, localPos + aimDirection)
end

-- Выбираем или снимаем цель
local function ToggleTarget()
    if State.SelectedTarget then
        State.SelectedTarget = nil
        if State.PredictionGui then
            State.PredictionGui.Enabled = false
        end
        ManageAutoRotate(true)
        State.CamlockTarget = nil
    else
        local newTarget = FindClosestTargetToCursor()
        if newTarget then
            State.SelectedTarget = newTarget
            State.CamlockTarget = newTarget
        end
    end
end

-- Основной цикл обновления
local function UpdateVisuals()
    if not State.SelectedTarget or not State.SelectedTarget:FindFirstChild(Settings.TargetPart) then
        if State.PredictionGui then
            State.PredictionGui.Enabled = false
        end
        ManageAutoRotate(true)
        return
    end
    local predictedPos = CalculatePrediction(State.SelectedTarget)
    if not predictedPos then return end
    if State.PredictionGui then
        State.PredictionGui.Adornee = State.SelectedTarget[Settings.TargetPart]
        State.PredictionGui.Enabled = true
        State.PredictionGui.StudsOffset = (predictedPos - State.SelectedTarget[Settings.TargetPart].Position) * 1.5
    end
    LookAtTarget()
end

-- Логика Camlock
local function UpdateCamlock()
    if not Settings.CamlockEnabled or not State.CamlockTarget or not State.CamlockTarget:FindFirstChild("Head") then
        return
    end
    local targetHead = State.CamlockTarget:FindFirstChild("Head")
    if not targetHead then
        local targetPart = State.CamlockTarget:FindFirstChild(Settings.TargetPart)
        if targetPart then
            targetHead = targetPart
        else
            return
        end
    end
    local targetPosition = targetHead.Position
    local currentCFrame = Camera.CFrame
    local targetCFrame = CFrame.new(currentCFrame.Position, targetPosition)
    Camera.CFrame = currentCFrame:Lerp(targetCFrame, Settings.CamlockSmoothness)
end

-- Инициализация
local function Init()
    CreateVisuals()
    table.insert(State.Connections, UserInputService.InputBegan:Connect(function(input, gameProcessed)
        if not gameProcessed then
            if input.UserInputType == Settings.Keybind then
                ToggleTarget()
            elseif input.KeyCode == Settings.BoostKeybind then
                TeleportToTarget()
            elseif input.KeyCode == Settings.TpBackKeybind then
                TpBack()
            elseif input.KeyCode == Settings.CamlockKeybind then
                Settings.CamlockEnabled = not Settings.CamlockEnabled
            end
        end
    end))
    table.insert(State.Connections, RunService.RenderStepped:Connect(function()
        UpdateVisuals()
        UpdateCamlock()
        local nearestTarget = FindClosestTargetToCursor()
        if nearestTarget and nearestTarget ~= State.SelectedTarget then
            createPartAbovePlayer(nearestTarget)
        end
    end))
    table.insert(State.Connections, Workspace.ChildRemoved:Connect(function(child)
        if child == State.SelectedTarget then
            State.SelectedTarget = nil
            ManageAutoRotate(true)
            State.CamlockTarget = nil
        end
        if child == State.CamlockTarget then
            State.CamlockTarget = nil
        end
    end))
    table.insert(State.Connections, LocalPlayer.CharacterRemoving:Connect(function()
        ManageAutoRotate(true)
    end))
end

-- Очистка
local function Cleanup()
    for _, conn in pairs(State.Connections) do
        conn:Disconnect()
    end
    State.Connections = {}
    ManageAutoRotate(true)
    ClearVisuals()
end

-- Запускаем скрипт
Init()

-- Возвращаем функции для управления
return {
    SetTarget = function(target)
        State.SelectedTarget = target
    end,
    GetCurrentTarget = function() return State.SelectedTarget end,
    UpdateSettings = function(newSettings)
        for key, value in pairs(newSettings) do
            if Settings[key] ~= nil then
                Settings[key] = value
            end
        end
        if State.PredictionGui then
            State.PredictionGui.Size = Settings.PredictionSize
            State.PredictionGui.Frame.BackgroundColor3 = Settings.PredictionColor
            State.PredictionGui.Frame.BackgroundTransparency = Settings.PredictionTransparency
        end
    end,
    Cleanup = Cleanup
}
