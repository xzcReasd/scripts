local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local Workspace = game:GetService("Workspace")
local Lighting = game:GetService("Lighting")
local LocalPlayer = Players.LocalPlayer
local Camera = Workspace.CurrentCamera

-- Настройки
local Settings = {
    Keybind = Enum.UserInputType.MouseButton3, -- Изменено на MouseButton3
    BoostKeybind = Enum.KeyCode.V,
    TargetPart = "HumanoidRootPart",
    LockAngleAtTarget = true,
    -- Настройки предсказания
    UsePrediction = true,
    Prediction = 0.17362,
    JumpOffset = 1.5,
    -- Настройки BoostToTarget
    BoostSpeed = 700,
    MaxBoostDistance = 10000,
    BoostCooldown = 0,
    StopDistance = 0,
    -- Визуализация
    PredictionColor = Color3.fromRGB(0, 255, 0),
    PredictionSize = UDim2.new(0, 20, 0, 20),
    PredictionTransparency = 0.5,
    -- Фильтры
    MaxDistance = 1000,
    FOV = 60,
    TargetNPCs = false,
    TargetPlayers = true,
    -- Camlock
    CamlockKeybind = Enum.KeyCode.K,
    CamlockSmoothness = 0.1,
    CamlockEnabled = false
}

-- Состояние
local State = {
    SelectedTarget = nil,
    PredictionGui = nil,
    OriginalAutoRotate = true,
    Connections = {},
    IsBoosting = false,
    LastBoostTime = 0,
    FixedBoostPosition = nil,
    CamlockTarget = nil
}

-- Создаем визуальные элементы (BillboardGui вместо Part)
local function CreateVisuals()
    State.PredictionGui = Instance.new("BillboardGui")
    State.PredictionGui.Name = "PredictionVisual"
    State.PredictionGui.Size = Settings.PredictionSize
    State.PredictionGui.AlwaysOnTop = true
    State.PredictionGui.Enabled = false
   
    local frame = Instance.new("Frame")
    frame.Size = UDim2.new(1, 0, 1, 0)
    frame.BackgroundColor3 = Settings.PredictionColor
    frame.BackgroundTransparency = Settings.PredictionTransparency
    frame.BorderSizePixel = 0
    frame.Parent = State.PredictionGui
   
    local corner = Instance.new("UICorner")
    corner.CornerRadius = UDim.new(1, 0)
    corner.Parent = frame
   
    State.PredictionGui.Parent = Workspace
end

-- Очищаем визуальные элементы
local function ClearVisuals()
    if State.PredictionGui then
        State.PredictionGui:Destroy()
        State.PredictionGui = nil
    end
end

-- Управление autorotate
local function ManageAutoRotate(enable)
    local character = LocalPlayer.Character
    if not character then return end
    local humanoid = character:FindFirstChildOfClass("Humanoid")
    if not humanoid then return end
    if enable then
        humanoid.AutoRotate = State.OriginalAutoRotate
    else
        State.OriginalAutoRotate = humanoid.AutoRotate
        humanoid.AutoRotate = false
    end
end

-- Рассчитываем velocity цели
local function CalculateVelocity(target)
    if not target or not target:FindFirstChild(Settings.TargetPart) then return Vector3.new() end
    return target[Settings.TargetPart].Velocity
end

-- Находим ближайшего игрока к курсору
local function FindClosestPlayerToCursor()
    local closestPlayer = nil
    local closestDistance = math.huge
    local mousePos = UserInputService:GetMouseLocation()
    local mouseRay = Camera:ViewportPointToRay(mousePos.X, mousePos.Y)
    for _, player in pairs(Players:GetPlayers()) do
        if player == LocalPlayer or not player.Character or not player.Character:FindFirstChild("Head") then continue end
        local head = player.Character:FindFirstChild("Head")
        local screenPos, onScreen = Camera:WorldToViewportPoint(head.Position)
        if onScreen then
            local screenDistance = (Vector2.new(screenPos.X, screenPos.Y) - mousePos).Magnitude
            if screenDistance < closestDistance then
                closestDistance = screenDistance
                closestPlayer = player
            end
        end
    end
    return closestPlayer
end

-- Рассчитываем предсказанную позицию
local function CalculatePrediction(target)
    if not target or not target:FindFirstChild(Settings.TargetPart) then return nil end
    local targetPart = target[Settings.TargetPart]
    local targetPos = targetPart.Position
    local targetVel = CalculateVelocity(target)
    local predictedPos = targetPos
    if Settings.UsePrediction then
        predictedPos = targetPos + (targetVel * Settings.Prediction)
        if targetVel.Y > 15 then
            predictedPos = predictedPos + Vector3.new(0, Settings.JumpOffset, 0)
        end
    end
    return predictedPos
end

-- Функция быстрого перемещения к цели с использованием CFrame
local function BoostToTarget()
    if State.IsBoosting or (tick() - State.LastBoostTime) < Settings.BoostCooldown then return end
    if not State.SelectedTarget or not State.SelectedTarget:FindFirstChild(Settings.TargetPart) then return end
    local character = LocalPlayer.Character
    if not character then return end
    local rootPart = character:FindFirstChild("HumanoidRootPart")
    if not rootPart then return end
    State.FixedBoostPosition = CalculatePrediction(State.SelectedTarget)
    if not State.FixedBoostPosition then return end
    local distance = (rootPart.Position - State.FixedBoostPosition).Magnitude
    if distance > Settings.MaxBoostDistance then
        State.FixedBoostPosition = rootPart.Position + (State.FixedBoostPosition - rootPart.Position).Unit * Settings.MaxBoostDistance
    end
    State.IsBoosting = true
    State.LastBoostTime = tick()
    local boostEffect = Instance.new("Part")
    boostEffect.Size = Vector3.new(5, 5, 5)
    boostEffect.Shape = Enum.PartType.Ball
    boostEffect.Material = Enum.Material.Neon
    boostEffect.Color = Color3.fromRGB(0, 150, 255)
    boostEffect.Transparency = 0.7
    boostEffect.Anchored = true
    boostEffect.CanCollide = false
    boostEffect.Position = rootPart.Position
    boostEffect.Parent = Workspace
    game:GetService("Debris"):AddItem(boostEffect, 0.5)
    local originalGravity = workspace.Gravity
    local originalVelocity = rootPart.Velocity
    workspace.Gravity = 0
    rootPart.Velocity = Vector3.new()
    local direction = (State.FixedBoostPosition - rootPart.Position).Unit
    local targetCFrame = CFrame.new(rootPart.Position, rootPart.Position + direction)
    local travelDistance = math.min((rootPart.Position - State.FixedBoostPosition).Magnitude - Settings.StopDistance, Settings.MaxBoostDistance)
    if travelDistance <= 0 then
        State.IsBoosting = false
        workspace.Gravity = originalGravity
        return
    end
    local travelTime = travelDistance / Settings.BoostSpeed
    local startTime = tick()
    local startPos = rootPart.Position
    local boostConnection
    boostConnection = RunService.Heartbeat:Connect(function(dt)
        if not State.SelectedTarget or not State.SelectedTarget:FindFirstChild(Settings.TargetPart) then
            State.IsBoosting = false
            workspace.Gravity = originalGravity
            boostConnection:Disconnect()
            return
        end
        local elapsed = tick() - startTime
        local progress = math.min(elapsed / travelTime, 1)
        local newPos = startPos:Lerp(State.FixedBoostPosition, progress)
        local newCFrame = CFrame.new(newPos, newPos + direction)
        rootPart.CFrame = newCFrame
        boostEffect.Position = newPos
        if progress >= 1 then
            State.IsBoosting = false
            workspace.Gravity = originalGravity
            boostConnection:Disconnect()
        end
    end)
end

-- Функция поворота персонажа к цели
local function LookAtTarget()
    if not Settings.LockAngleAtTarget or not State.SelectedTarget then
        ManageAutoRotate(true)
        return
    end
    local character = LocalPlayer.Character
    if not character then return end
    local rootPart = character:FindFirstChild("HumanoidRootPart")
    if not rootPart then return end
    local predictedPos = CalculatePrediction(State.SelectedTarget)
    if not predictedPos then return end
    ManageAutoRotate(false)
    local localPos = rootPart.Position
    local aimDirection = (predictedPos - localPos).Unit
    aimDirection = Vector3.new(aimDirection.X, 0, aimDirection.Z).Unit
    rootPart.CFrame = CFrame.new(localPos, localPos + aimDirection)
end

-- Выбираем или снимаем цель
local function ToggleTarget()
    if State.SelectedTarget then
        State.SelectedTarget = nil
        if State.PredictionGui then
            State.PredictionGui.Enabled = false
        end
        ManageAutoRotate(true)
        State.CamlockTarget = nil
    else
        local newTarget = FindClosestPlayerToCursor()
        if newTarget and newTarget.Character then
            State.SelectedTarget = newTarget.Character
            State.CamlockTarget = newTarget
        end
    end
end

-- Основной цикл обновления
local function UpdateVisuals()
    if not State.SelectedTarget or not State.SelectedTarget:FindFirstChild(Settings.TargetPart) then
        if State.PredictionGui then
            State.PredictionGui.Enabled = false
        end
        ManageAutoRotate(true)
        return
    end
    local predictedPos = CalculatePrediction(State.SelectedTarget)
    if not predictedPos then return end
    if State.PredictionGui then
        State.PredictionGui.Adornee = State.SelectedTarget[Settings.TargetPart]
        State.PredictionGui.Enabled = true
        State.PredictionGui.StudsOffset = (predictedPos - State.SelectedTarget[Settings.TargetPart].Position) * 1.5
    end
    LookAtTarget()
end

-- Логика Camlock
local function UpdateCamlock()
    if not Settings.CamlockEnabled or not State.CamlockTarget or not State.CamlockTarget.Character or not State.CamlockTarget.Character:FindFirstChild("Head") then
        return
    end
    local targetHead = State.CamlockTarget.Character.Head
    local targetPosition = targetHead.Position
    local currentCFrame = Camera.CFrame
    local targetCFrame = CFrame.new(currentCFrame.Position, targetPosition)
    Camera.CFrame = currentCFrame:Lerp(targetCFrame, Settings.CamlockSmoothness)
end

-- Инициализация
local function Init()
    CreateVisuals()
    table.insert(State.Connections, UserInputService.InputBegan:Connect(function(input, gameProcessed)
        if not gameProcessed then
            if input.UserInputType == Settings.Keybind then
                ToggleTarget()
            elseif input.KeyCode == Settings.BoostKeybind then
                BoostToTarget()
            elseif input.KeyCode == Settings.CamlockKeybind then
                Settings.CamlockEnabled = not Settings.CamlockEnabled
            end
        end
    end))
    table.insert(State.Connections, RunService.RenderStepped:Connect(function()
        UpdateVisuals()
        UpdateCamlock()
    end))
    table.insert(State.Connections, Workspace.ChildRemoved:Connect(function(child)
        if child == State.SelectedTarget then
            State.SelectedTarget = nil
            ManageAutoRotate(true)
            State.CamlockTarget = nil
        end
        if child == State.CamlockTarget and State.CamlockTarget.Character then
            State.CamlockTarget = nil
        end
    end))
    table.insert(State.Connections, LocalPlayer.CharacterRemoving:Connect(function()
        ManageAutoRotate(true)
    end))
end

-- Очистка
local function Cleanup()
    for _, conn in pairs(State.Connections) do
        conn:Disconnect()
    end
    State.Connections = {}
    ManageAutoRotate(true)
    ClearVisuals()
end

-- Запускаем скрипт
Init()

-- Возвращаем функции для управления
return {
    SetTarget = function(target)
        State.SelectedTarget = target
    end,
    GetCurrentTarget = function() return State.SelectedTarget end,
    UpdateSettings = function(newSettings)
        for key, value in pairs(newSettings) do
            if Settings[key] ~= nil then
                Settings[key] = value
            end
        end
        if State.PredictionGui then
            State.PredictionGui.Size = Settings.PredictionSize
            State.PredictionGui.Frame.BackgroundColor3 = Settings.PredictionColor
            State.PredictionGui.Frame.BackgroundTransparency = Settings.PredictionTransparency
        end
    end,
    Cleanup = Cleanup
}
